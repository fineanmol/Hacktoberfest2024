"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {};
exports["default"] = void 0;

var Utils = _interopRequireWildcard(require("./utils"));

var _types = require("./types");

Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _types[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _types[key];
    }
  });
});

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var VanillaSwipe = /*#__PURE__*/function () {
  function VanillaSwipe(props) {
    _classCallCheck(this, VanillaSwipe);

    _defineProperty(this, "state", void 0);

    _defineProperty(this, "props", void 0);

    this.state = Utils.getInitialState();
    this.props = Utils.getInitialProps(props);
    this.handleSwipeStart = this.handleSwipeStart.bind(this);
    this.handleSwipeMove = this.handleSwipeMove.bind(this);
    this.handleSwipeEnd = this.handleSwipeEnd.bind(this);
    this.handleMouseDown = this.handleMouseDown.bind(this);
    this.handleMouseMove = this.handleMouseMove.bind(this);
    this.handleMouseUp = this.handleMouseUp.bind(this);
    this.handleMouseLeave = this.handleMouseLeave.bind(this);
  }

  _createClass(VanillaSwipe, [{
    key: "init",
    value: function init() {
      this.setupTouchListeners();
      this.setupMouseListeners();
    }
  }, {
    key: "update",
    value: function update(props) {
      var prevProps = this.props;
      var nextProps = Object.assign({}, prevProps, props);

      if (prevProps.element !== nextProps.element || prevProps.target !== nextProps.target) {
        this.destroy();
        this.props = nextProps;
        this.init();
        return;
      }

      this.props = nextProps;

      if (prevProps.mouseTrackingEnabled !== nextProps.mouseTrackingEnabled || prevProps.preventTrackingOnMouseleave !== nextProps.preventTrackingOnMouseleave) {
        this.cleanupMouseListeners();
        nextProps.mouseTrackingEnabled ? this.setupMouseListeners() : this.cleanupMouseListeners();
      }

      if (prevProps.touchTrackingEnabled !== nextProps.touchTrackingEnabled) {
        this.cleanupTouchListeners();
        nextProps.touchTrackingEnabled ? this.setupTouchListeners() : this.cleanupTouchListeners();
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.cleanupMouseListeners();
      this.cleanupTouchListeners();
      this.state = Utils.getInitialState();
      this.props = Utils.getInitialProps();
    }
  }, {
    key: "setupTouchListeners",
    value: function setupTouchListeners() {
      var _this$props = this.props,
          element = _this$props.element,
          target = _this$props.target,
          touchTrackingEnabled = _this$props.touchTrackingEnabled;

      if (element && touchTrackingEnabled) {
        var listener = target || element;
        var isPassiveSupported = Utils.checkIsPassiveSupported();
        var options = Utils.getOptions(isPassiveSupported);
        listener.addEventListener('touchstart', this.handleSwipeStart, options);
        listener.addEventListener('touchmove', this.handleSwipeMove, options);
        listener.addEventListener('touchend', this.handleSwipeEnd, options);
      }
    }
  }, {
    key: "cleanupTouchListeners",
    value: function cleanupTouchListeners() {
      var _this$props2 = this.props,
          element = _this$props2.element,
          target = _this$props2.target;
      var listener = target || element;

      if (listener) {
        listener.removeEventListener('touchstart', this.handleSwipeStart);
        listener.removeEventListener('touchmove', this.handleSwipeMove);
        listener.removeEventListener('touchend', this.handleSwipeEnd);
      }
    }
  }, {
    key: "setupMouseListeners",
    value: function setupMouseListeners() {
      var _this$props3 = this.props,
          element = _this$props3.element,
          mouseTrackingEnabled = _this$props3.mouseTrackingEnabled,
          preventTrackingOnMouseleave = _this$props3.preventTrackingOnMouseleave;

      if (mouseTrackingEnabled && element) {
        element.addEventListener('mousedown', this.handleMouseDown);
        element.addEventListener('mousemove', this.handleMouseMove);
        element.addEventListener('mouseup', this.handleMouseUp);

        if (preventTrackingOnMouseleave) {
          element.addEventListener('mouseleave', this.handleMouseLeave);
        }
      }
    }
  }, {
    key: "cleanupMouseListeners",
    value: function cleanupMouseListeners() {
      var element = this.props.element;

      if (element) {
        element.removeEventListener('mousedown', this.handleMouseDown);
        element.removeEventListener('mousemove', this.handleMouseMove);
        element.removeEventListener('mouseup', this.handleMouseUp);
        element.removeEventListener('mouseleave', this.handleMouseLeave);
      }
    }
  }, {
    key: "getEventData",
    value: function getEventData(e) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        directionDelta: 0
      };
      var rotationAngle = this.props.rotationAngle;
      var directionDelta = options.directionDelta;
      var movingPosition = Utils.calculateMovingPosition(e);
      var rotatePosition = Utils.rotateByAngle(movingPosition, rotationAngle);
      return Utils.calculatePosition(this.state, {
        rotatePosition: rotatePosition,
        directionDelta: directionDelta
      });
    }
  }, {
    key: "handleSwipeStart",
    value: function handleSwipeStart(e) {
      if (Utils.checkIsMoreThanSingleTouches(e)) return;
      var rotationAngle = this.props.rotationAngle;
      var movingPosition = Utils.calculateMovingPosition(e);

      var _Utils$rotateByAngle = Utils.rotateByAngle(movingPosition, rotationAngle),
          x = _Utils$rotateByAngle.x,
          y = _Utils$rotateByAngle.y;

      this.state = Utils.getInitialState({
        isSwiping: false,
        start: Date.now(),
        x: x,
        y: y
      });
    }
  }, {
    key: "handleSwipeMove",
    value: function handleSwipeMove(e) {
      var _this$state = this.state,
          x = _this$state.x,
          y = _this$state.y,
          isSwiping = _this$state.isSwiping;
      if (!x || !y || Utils.checkIsMoreThanSingleTouches(e)) return;
      var directionDelta = this.props.directionDelta || 0;

      var _this$getEventData = this.getEventData(e, {
        directionDelta: directionDelta
      }),
          absX = _this$getEventData.absX,
          absY = _this$getEventData.absY,
          deltaX = _this$getEventData.deltaX,
          deltaY = _this$getEventData.deltaY,
          directionX = _this$getEventData.directionX,
          directionY = _this$getEventData.directionY,
          duration = _this$getEventData.duration,
          velocity = _this$getEventData.velocity;

      var _this$props4 = this.props,
          delta = _this$props4.delta,
          preventDefaultTouchmoveEvent = _this$props4.preventDefaultTouchmoveEvent,
          onSwipeStart = _this$props4.onSwipeStart,
          onSwiping = _this$props4.onSwiping;
      if (e.cancelable && preventDefaultTouchmoveEvent) e.preventDefault();
      if (absX < Number(delta) && absY < Number(delta) && !isSwiping) return;

      if (onSwipeStart && !isSwiping) {
        onSwipeStart(e, {
          deltaX: deltaX,
          deltaY: deltaY,
          absX: absX,
          absY: absY,
          directionX: directionX,
          directionY: directionY,
          duration: duration,
          velocity: velocity
        });
      }

      this.state.isSwiping = true;

      if (onSwiping) {
        onSwiping(e, {
          deltaX: deltaX,
          deltaY: deltaY,
          absX: absX,
          absY: absY,
          directionX: directionX,
          directionY: directionY,
          duration: duration,
          velocity: velocity
        });
      }
    }
  }, {
    key: "handleSwipeEnd",
    value: function handleSwipeEnd(e) {
      var _this$props5 = this.props,
          onSwiped = _this$props5.onSwiped,
          onTap = _this$props5.onTap;

      if (this.state.isSwiping) {
        var directionDelta = this.props.directionDelta || 0;
        var position = this.getEventData(e, {
          directionDelta: directionDelta
        });
        onSwiped && onSwiped(e, position);
      } else {
        var _position = this.getEventData(e);

        onTap && onTap(e, _position);
      }

      this.state = Utils.getInitialState();
    }
  }, {
    key: "handleMouseDown",
    value: function handleMouseDown(e) {
      var target = this.props.target;

      if (target) {
        if (target === e.target) {
          this.handleSwipeStart(e);
        }
      } else {
        this.handleSwipeStart(e);
      }
    }
  }, {
    key: "handleMouseMove",
    value: function handleMouseMove(e) {
      this.handleSwipeMove(e);
    }
  }, {
    key: "handleMouseUp",
    value: function handleMouseUp(e) {
      var isSwiping = this.state.isSwiping;
      var target = this.props.target;

      if (target) {
        if (target === e.target || isSwiping) {
          this.handleSwipeEnd(e);
        }
      } else {
        this.handleSwipeEnd(e);
      }
    }
  }, {
    key: "handleMouseLeave",
    value: function handleMouseLeave(e) {
      var isSwiping = this.state.isSwiping;

      if (isSwiping) {
        this.handleSwipeEnd(e);
      }
    }
  }], [{
    key: "isTouchEventsSupported",
    value: function isTouchEventsSupported() {
      return Utils.checkIsTouchEventsSupported();
    }
  }]);

  return VanillaSwipe;
}();

exports["default"] = VanillaSwipe;